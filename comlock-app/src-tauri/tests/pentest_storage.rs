use aes_gcm::{
    aead::{Aead, KeyInit},
    Aes256Gcm, Nonce,
};
use rand::RngCore;
use sha2::{Digest, Sha256};
use std::fs::File;
use std::io::{Read, Write};

#[test]
fn test_storage_decryption_without_pin_fails() {
    // 1. Simulate creating a secure file (as the app would)
    // We are reimplementing the logic to ensure we are testing the *concept*
    // regardless of internal API visibility.
    let pin = "1234";
    let output_path = "security_pentest.enc";

    // Derive key (mimicking SecureStorage::derive_key)
    let mut hasher = Sha256::new();
    hasher.update(b"COMLOCK_STORAGE_KEY_V1");
    hasher.update(pin.as_bytes());
    hasher.update(b"COMLOCK_STORAGE_KEY_V1");
    let key: [u8; 32] = hasher.finalize().into();

    // Encrypt some data
    let plaintext = b"{\"secret\": \"data\"}";
    let mut nonce_bytes = [0u8; 12];
    rand::thread_rng().fill_bytes(&mut nonce_bytes);
    let nonce = Nonce::from_slice(&nonce_bytes);

    let cipher = Aes256Gcm::new_from_slice(&key).unwrap();
    let ciphertext = cipher.encrypt(nonce, plaintext.as_ref()).unwrap();

    // Write file: nonce + ciphertext
    {
        let mut file = File::create(output_path).expect("Failed to create file");
        file.write_all(&nonce_bytes).unwrap();
        file.write_all(&ciphertext).unwrap();
    }

    // 2. Simulate Attacker trying to decrypt WITHOUT the correct PIN
    // Brute force attempt (simulated with just one wrong guess)
    let attacker_pin = "0000";
    let mut hasher = Sha256::new();
    hasher.update(b"COMLOCK_STORAGE_KEY_V1");
    hasher.update(attacker_pin.as_bytes()); // Wrong PIN
    hasher.update(b"COMLOCK_STORAGE_KEY_V1");
    let attacker_key: [u8; 32] = hasher.finalize().into();

    // Read file
    let mut file = File::open(output_path).expect("Failed to open file");
    let mut data = Vec::new();
    file.read_to_end(&mut data).unwrap();

    assert!(data.len() > 12, "File too short");

    let nonce_extracted = Nonce::from_slice(&data[..12]);
    let ciphertext_extracted = &data[12..];

    let attacker_cipher = Aes256Gcm::new_from_slice(&attacker_key).unwrap();
    let result = attacker_cipher.decrypt(nonce_extracted, ciphertext_extracted);

    // Cleanup
    let _ = std::fs::remove_file(output_path);

    // 3. Assert failure
    assert!(
        result.is_err(),
        "Decryption succeeded with wrong PIN! CRYPTO BROKEN."
    );
}
